
# Лабораторна робота №11. Вступ до показчиків

## 1. Вимоги

### 1.1 Розробник

- Макаренко Владислав Олександрович;

- студент групи КІТ-120а;

- 22-груд-2020

### 1.2 Загальне завдання

Виконати всі завдання на тему показчики

### 1.3 Індивідуальне завдання

 Визначити, чи є в масиві елементи, що повторюються; якщо такі є, створити масив, в якому вказати скільки разів які елементи повторюються.
 
## 2. Опис програми

### 2.1 Функціональне призначення

За допомогою показчиків, программа Визначає, чи є в масиві елементи, що повторюються; якщо такі є, то вона створює масив, в якому вказує скільки разів які елементи повторюються. Таким чином, в результуючому масиві кожен не парний елемент - число, що повторюється; кожен парний елемент - кількість повторювань

### 2.2 Опис логічної структури програми

Створюємо вхідний масив, та заповнюємо його за допомогою функції `fill_initial_array`. Створюємо масив того ж розміру, що й вихідний, та за допомогою функції `fill_array_of_repeats` заповнюємо його елементами, які вказують на кількість повторів відповідного елемента у вхідному масиві. Потім за допомогою функції `size_of_result` дізнаємось розмір результуючого масиву та створюємо його. Далі за допомогою функції `fill_result_array` заповнюємо результуючий масив необхідними елементами.

_Головна функція_`main()`. Створює вхідний масив; створює масив з кількістю  повторів елементів у вхідному масиві; викликає функціі `fill_initial_array`, `fill_array_of_repeats`, `size_of_result`; створює динамічний масив  та викикає функцію `fill_result_array` для його заповнення . _Схема алгоритму функції_ подана на рис. 1.

![Схема алгоритму функції](https://github.com/Vlad-Makarenko/Programing-repo/blob/main/lab11/doc/assets/main.png?raw=true)
Рисунок 1  --- Схема алгоритму функції `main`


_Функція, що заповнює вхідний масив_ `fill_initial_array`. Заповнює вхідний масив випадковими числами від 1 до 5. _Схема алгоритму функції_ подана на рис. 2.

![Схема алгоритму функції](https://github.com/Vlad-Makarenko/Programing-repo/blob/main/lab11/doc/assets/fill_initial_array.png?raw=true)
Рисунок 2 --- Схема алгоритму функції `fill_initial_array`

_Функція, що заповнює масив повторів_ `fill_array_of_repeats`. Заповнює створений масив кількістю повторів кожного елементу вхідного масиву відповідно. _Схема алгоритму функції_ подана на рис. 3.

![enter image description here](https://github.com/Vlad-Makarenko/Programing-repo/blob/main/lab11/doc/assets/fill_array_of_repeats.png?raw=true)
Рисунок 3 --- Схема алгоритму функції `fill_array_of_repeats`

_Функція, що рахує розмір результуючого самиву_ `size_of_result`. Фнукція рахує розмір результуючого масиву. Переметри: `new_size` - розмір результуючого масиву, `flag`- змінна для перевірки умови. Функція повертає  `new_size`. _Схема алгоритму функції_ подана на рис. 4.

![enter image description here](https://github.com/Vlad-Makarenko/Programing-repo/blob/main/lab11/doc/assets/size_of_result.png?raw=true)
Рисунок 4 --- Схема алгоритму функції `size_of_result`

_Функція, заповнює результуючий масив_ `fill_result_array`. Функція заповнює результуючий масив необхідними елементами. Переметри: `k` - змінна для правильного заповнення результуючого масиву, `flag`- змінна для перевірки умови. _Схема алгоритму функції_ подана на рис. 5.

![enter image description here](https://github.com/Vlad-Makarenko/Programing-repo/blob/main/lab11/doc/assets/fill_result_array.png?raw=true)
Рисунок 5 --- Схема алгоритму функції `fill_result_array`

#### Структура проекту

    ├──lab11
    ├── Doxyfile
    ├── Makefile
    ├── doc
        ├── lab11.md
        └── assets
    └── src
        ├── main1.c
        ├── main2.c
        ├── main3.c
        └── main4.c

### 2.3 Важливі фрагменти програми

#### Підключення заголовочного stdlib.h та time.h для генерації випадкових чисел.

`#include <stdlib.h>`
`#include <time.h>`

#### Створення та виклик функцій для заповнення масивів

    int initial_array[SIZE] = {0};
    int array_of_repeats[SIZE] = {0};
	fill_initial_array(SIZE, initial_array);
	fill_array_of_repeats(SIZE, initial_array, array_of_repeats);

#### Виклик функції, яка розрахує розмір результуючого масиву; та його створення

	int new_size = size_of_result(SIZE, initial_array, array_of_repeats);
	int *result_array = malloc(new_size * 2 * sizeof(int));

#### Заповнення результуючого масиву
	int k = 0;
	int flag = 0;
	for (int i = 0; i < SIZE; i++){
		if (array_of_repeats[i] == 1){
			continue;
		}else{
			for (int j = 0; j < i; j++){
				if(initial_array[i] == initial_array[j]) {
					flag = 1;
				}
			}
			if (flag == 0){
				*(result_array + k) = initial_array[i];
				*(result_array + k + 1) = array_of_repeats[i];
				k += 2;
			}
			flag = 0;
		}
	}

### 3. Варіанти використання

Для демонстрації результатів використовується покрокове виконання програми та інші засоби налагодження відлагодника nemiver. Нижче наводиться послідовність  дій запуску програми у режимі відлагодження.

_Крок 1_ (рис.6 ). Виконуємо функцію для заповнення вхідного масиву випадковими числами

![result1](https://github.com/Vlad-Makarenko/Programing-repo/blob/main/lab11/doc/assets/initial_array.png?raw=true)
Рисунок 6 --- Результат виконання функції для першого кроку

_Крок 2_ (див. рис.7 ). Виконуємо функцію для заповнення масиву кількістю повторів елементів у вхідному масиві відповідно

![result2](https://github.com/Vlad-Makarenko/Programing-repo/blob/main/lab11/doc/assets/array_of_repeats.png?raw=true)
Рисунок 7 --- Результат виконання функції для другого кроку

_Крок 3_ (див. рис.8 ). Виконуємо функцію для заповнення результуючого масиву

![result3](https://github.com/Vlad-Makarenko/Programing-repo/blob/main/lab11/doc/assets/result_array.png?raw=true)
Рисунок 8 --- Результат виконання функції для третього кроку

## Висновки

Ми навчились розробляти програми використовуючи показчики.

